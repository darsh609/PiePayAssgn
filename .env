
PORT = 5000
MONGO_URI = "mongodb+srv://darshkumar0609_db_user:NUvvlxI71kKrRxNQ@cluster0.sz0h28s.mongodb.net/"




# // index.js
# require('dotenv').config();
# const express = require('express');
# const mongoose = require('mongoose');
# const crypto = require('crypto');

# const app = express();
# app.use(express.json({ limit: '20mb' }));

# /* ----------------- Mongoose model ----------------- */
# const OfferSchema = new mongoose.Schema({
#   externalId: { type: String, index: true, sparse: true }, // Flipkart offer id if present
#   dedupeHash: { type: String, index: true, unique: true, sparse: true }, // stable hash
#   title: String,
#   summaryTitle: String,
#   logo: String,
#   providers: [String],
#   description: String,
#   tncText: String,
#   minTxnAmount: Number,
#   maxDiscount: Number,
#   rawPayload: { type: mongoose.Schema.Types.Mixed },
#   createdAt: { type: Date, default: Date.now }
# }, { strict: false });

# const Offer = mongoose.model('Offer', OfferSchema);

# /* ----------------- Helpers ----------------- */
# function stableStringify(o) {
#   if (o === null) return 'null';
#   if (typeof o !== 'object') return JSON.stringify(o);
#   if (Array.isArray(o)) return '[' + o.map(stableStringify).join(',') + ']';
#   const keys = Object.keys(o).sort();
#   return '{' + keys.map(k => JSON.stringify(k) + ':' + stableStringify(o[k])).join(',') + '}';
# }
# function computeHash(obj) {
#   return crypto.createHash('sha256').update(stableStringify(obj)).digest('hex');
# }
# function parseRupeeAmount(text) {
#   if (!text || typeof text !== 'string') return null;
#   const re = /₹\s*([\d,]+)/;
#   const m = text.match(re);
#   if (!m) return null;
#   const digits = m[1].replace(/,/g, '');
#   let num = 0;
#   for (let i=0;i<digits.length;i++){
#     const d = digits.charCodeAt(i)-48;
#     if (d>=0 && d<=9) num = num*10 + d;
#     else return null;
#   }
#   return num;
# }
# function parseMaxDiscount(text) {
#   if (!text || typeof text !== 'string') return null;
#   const re = /up to\s*₹\s*([\d,]+)/i;
#   const m = text.match(re) || text.match(/upto\s*₹\s*([\d,]+)/i);
#   if (!m) return null;
#   const digits = m[1].replace(/,/g,'');
#   let num = 0;
#   for (let i=0;i<digits.length;i++){
#     const d = digits.charCodeAt(i)-48;
#     if (d>=0 && d<=9) num = num*10 + d;
#     else return null;
#   }
#   return num;
# }

# /* ----------------- Extractors ----------------- */
# /*
# We handle the common Flipkart structure you showed:
# payload.paymentOptions.items[].data:
#   - item.data.offerSummary
#   - item.data.offers.offerList[]  <-- primary source

# We also include a fallback recursive scan for objects that look like offers.
# */
# function extractFromOfferListStructure(payload) {
#   const out = [];
#   if (!payload || typeof payload !== 'object') return out;
#   const paymentOptions = payload.paymentOptions;
#   if (!paymentOptions || !Array.isArray(paymentOptions.items)) return out;

#   for (const item of paymentOptions.items) {
#     if (!item || !item.data) continue;
#     const summary = item.data.offerSummary || null;
#     const offersContainer = item.data.offers || item.data; // sometimes nested differently
#     const list = offersContainer && offersContainer.offerList ? offersContainer.offerList : null;
#     if (!Array.isArray(list)) continue;

#     for (const o of list) {
#       const externalId = o.offerDescription && o.offerDescription.id ? o.offerDescription.id : null;
#       const title = o.offerText && o.offerText.text ? o.offerText.text : (o.title || null);
#       const description = o.offerDescription && o.offerDescription.text ? o.offerDescription.text : (o.desc || null);
#       const tncText = o.offerDescription && o.offerDescription.tncText ? o.offerDescription.tncText : null;
#       const logo = o.logo || (summary && summary.iconsInfo && Array.isArray(summary.iconsInfo.icons) ? summary.iconsInfo.icons[0] : null);
#       const providers = Array.isArray(o.provider) ? o.provider : [];

#       const minTxnAmount = parseRupeeAmount(description);
#       const maxDiscount = parseMaxDiscount(description) || parseRupeeAmount(title) || null;

#       const normalized = {
#         externalId,
#         dedupeHash: computeHash({ externalId, title, description, providers }),
#         title,
#         summaryTitle: summary ? summary.title : null,
#         logo,
#         providers,
#         description,
#         tncText,
#         minTxnAmount,
#         maxDiscount,
#         rawPayload: o
#       };
#       out.push(normalized);
#     }
#   }
#   return out;
# }

# // Generic fallback scan: recursively find objects with "offer"/"promo"/"coupon" keys
# function looksLikeOffer(o) {
#   if (!o || typeof o !== 'object') return false;
#   const keys = Object.keys(o).map(k => k.toLowerCase());
#   const signals = ['offer','promo','coupon','discount','offertext','offerdescription','tnc'];
#   return signals.some(sig => keys.some(k => k.includes(sig)));
# }
# function recursiveScanForOffers(obj, out = []) {
#   if (!obj || typeof obj !== 'object') return out;
#   if (Array.isArray(obj)) {
#     for (const it of obj) recursiveScanForOffers(it, out);
#     return out;
#   }
#   if (looksLikeOffer(obj)) out.push(obj);
#   for (const k of Object.keys(obj)) {
#     const v = obj[k];
#     if (v && typeof v === 'object') recursiveScanForOffers(v, out);
#   }
#   return out;
# }
# function normalizeGenericCandidate(o) {
#   const get = (alts) => {
#     for (const a of alts) {
#       if (o[a] != null) return o[a];
#       const found = Object.keys(o).find(k => k.toLowerCase() === a.toLowerCase());
#       if (found) return o[found];
#     }
#     return undefined;
#   };
#   const externalId = get(['id','offerId','couponId','promoId']);
#   const title = get(['title','offerText','offerTitle','text','headline']) || null;
#   const description = get(['description','offerDescription','desc','text']) || null;
#   const providers = Array.isArray(get(['provider','providers'])) ? get(['provider','providers']) : [];
#   return {
#     externalId,
#     dedupeHash: computeHash({ externalId, title, description, providers }),
#     title,
#     summaryTitle: null,
#     logo: get(['logo']),
#     providers,
#     description,
#     tncText: get(['tncText']),
#     minTxnAmount: parseRupeeAmount(description),
#     maxDiscount: parseMaxDiscount(description) || parseRupeeAmount(title) || null,
#     rawPayload: o
#   };
# }

# /* ----------------- POST /offer ----------------- */
# app.post('/offer', async (req, res) => {
#   try {
#     const payload = req.body.flipkartOfferApiResponse || req.body;
#     if (!payload || Object.keys(payload).length === 0) {
#       return res.status(400).json({ error: 'flipkartOfferApiResponse missing or empty' });
#     }

#     // 1) Preferred extractor for the known Flipkart structure
#     let normalized = extractFromOfferListStructure(payload);

#     // 2) If nothing found, fallback to generic recursive scan + normalize
#     if (!normalized || normalized.length === 0) {
#       const candidates = recursiveScanForOffers(payload);
#       const uniq = [];
#       const seen = new Set();
#       for (const c of candidates) {
#         try {
#           const key = JSON.stringify(c, Object.keys(c).sort());
#           if (!seen.has(key)) { uniq.push(c); seen.add(key); }
#         } catch (e) { uniq.push(c); }
#       }
#       normalized = uniq.map(normalizeGenericCandidate);
#     }

#     // 3) Final dedupe by normalized dedupeHash within the request (avoid duplicates in same payload)
#     const finalMap = new Map();
#     for (const n of normalized) {
#       if (!finalMap.has(n.dedupeHash)) finalMap.set(n.dedupeHash, n);
#     }
#     const finalList = Array.from(finalMap.values());
#     const noOfOffersIdentified = finalList.length;

#     // 4) Insert into DB if not exists (by externalId then dedupeHash)
#     let noOfNewOffersCreated = 0;
#     for (const n of finalList) {
#       let exists = null;
#       if (n.externalId) {
#         exists = await Offer.findOne({ externalId: n.externalId }).lean();
#       }
#       if (!exists) {
#         exists = await Offer.findOne({ dedupeHash: n.dedupeHash }).lean();
#       }
#       if (!exists) {
#         try {
#           await Offer.create(n);
#           noOfNewOffersCreated++;
#         } catch (e) {
#           // unique index race or other insert error => treat as duplicate
#           if (e.code === 11000) {
#             // duplicate - ignore
#           } else {
#             console.error('DB insert error', e);
#           }
#         }
#       }
#     }

#     return res.json({ noOfOffersIdentified, noOfNewOffersCreated });
#   } catch (err) {
#     console.error('POST /offer error', err);
#     return res.status(500).json({ error: 'internal_error' });
#   }
# });

# /* ----------------- Start server ----------------- */
# const PORT = process.env.PORT || 3000;
# const MONGO = process.env.MONGO_URI || 'mongodb://localhost:27017/piepay_offers';

# mongoose.connect(MONGO, { useNewUrlParser: true, useUnifiedTopology: true })
#   .then(() => app.listen(PORT, () => console.log(`Server running on ${PORT}`)))
#   .catch(err => {
#     console.error('mongo connect failed', err);
#     process.exit(1);
#   });










































# # // index.js
# # require('dotenv').config();
# # const express = require('express');
# # const mongoose = require('mongoose');
# # const crypto = require('crypto');

# # const app = express();
# # app.use(express.json({ limit: '15mb' }));

# # // ---------------- Mongoose model ----------------
# # const OfferSchema = new mongoose.Schema({
# #   externalId: { type: String, index: true, sparse: true },
# #   dedupeHash: { type: String, index: true, unique: true, sparse: true },
# #   title: String,
# #   summaryTitle: String,
# #   logo: String,
# #   providers: [String],
# #   description: String,
# #   tncText: String,
# #   minTxnAmount: Number,
# #   maxDiscount: Number,
# #   rawPayload: { type: mongoose.Schema.Types.Mixed },
# #   createdAt: { type: Date, default: Date.now }
# # }, { strict: false });

# # const Offer = mongoose.model('Offer', OfferSchema);

# # // ---------------- Helpers ----------------
# # function computeHash(obj) {
# #   const stableStringify = (o) => {
# #     if (o === null) return 'null';
# #     if (typeof o !== 'object') return JSON.stringify(o);
# #     if (Array.isArray(o)) return '[' + o.map(stableStringify).join(',') + ']';
# #     const keys = Object.keys(o).sort();
# #     return '{' + keys.map(k => JSON.stringify(k) + ':' + stableStringify(o[k])).join(',') + '}';
# #   };
# #   return crypto.createHash('sha256').update(stableStringify(obj)).digest('hex');
# # }

# # // parse first occurrence of ₹number (with commas) -> Number
# # function parseRupeeAmount(text) {
# #   if (!text || typeof text !== 'string') return null;
# #   const re = /₹\s*([\d,]+)/; // captures '₹1,250' or '₹ 1,250'
# #   const match = text.match(re);
# #   if (!match) return null;
# #   const digits = match[1].replace(/,/g, '');
# #   // parse digit-by-digit to be safe
# #   let num = 0;
# #   for (let i = 0; i < digits.length; i++) {
# #     const d = digits.charCodeAt(i) - 48; // '0' -> 48
# #     if (d >= 0 && d <= 9) {
# #       num = num * 10 + d;
# #     } else {
# #       // non-digit: abort
# #       return null;
# #     }
# #   }
# #   return num;
# # }

# # // parse 'up to ₹X' -> max discount
# # function parseMaxDiscount(text) {
# #   if (!text || typeof text !== 'string') return null;
# #   const re = /up to\s*₹\s*([\d,]+)/i;
# #   let m = text.match(re);
# #   if (m) {
# #     const digits = m[1].replace(/,/g, '');
# #     let num = 0;
# #     for (let i = 0; i < digits.length; i++) {
# #       const d = digits.charCodeAt(i) - 48;
# #       if (d >= 0 && d <= 9) num = num * 10 + d;
# #       else return null;
# #     }
# #     return num;
# #   }
# #   // also try 'upto ₹X' or 'upto₹X' variation
# #   const re2 = /upto\s*₹\s*([\d,]+)/i;
# #   m = text.match(re2);
# #   if (m) {
# #     const digits = m[1].replace(/,/g, '');
# #     let num = 0;
# #     for (let i = 0; i < digits.length; i++) {
# #       const d = digits.charCodeAt(i) - 48;
# #       if (d >= 0 && d <= 9) num = num * 10 + d;
# #       else return null;
# #     }
# #     return num;
# #   }
# #   return null;
# # }

# # // ---------------- Normalizer for the exact payload shape you posted ----------------
# # // Top-level path: payload.paymentOptions.items[] where item.type === 'OFFER_LIST'
# # // inside: item.data.offerSummary and item.data.offers.offerList[]
# # function extractOffersFromPaymentsResponse(payload) {
# #   const out = [];
# #   if (!payload || typeof payload !== 'object') return out;
# #   const paymentOptions = payload.paymentOptions;
# #   if (!paymentOptions || !Array.isArray(paymentOptions.items)) return out;

# #   for (const item of paymentOptions.items) {
# #     // we only care types containing OFFERS
# #     if (!item || !item.data) continue;
# #     const summary = item.data.offerSummary || null;
# #     const offersContainer = item.data.offers || null;
# #     if (!offersContainer || !Array.isArray(offersContainer.offerList)) continue;

# #     for (const offerObj of offersContainer.offerList) {
# #       // Each offerObj example from you:
# #       // { provider: [], logo: "...", offerText: { text: "Get ₹15 cashback" }, offerDescription: { id:"FPO..", text: "Flat ₹15 Cashback ...", tncText: "Terms and conditions"} }
# #       const externalId = offerObj.offerDescription && offerObj.offerDescription.id ? offerObj.offerDescription.id : null;
# #       const title = (offerObj.offerText && offerObj.offerText.text) ? offerObj.offerText.text : null;
# #       const description = (offerObj.offerDescription && offerObj.offerDescription.text) ? offerObj.offerDescription.text : null;
# #       const tncText = (offerObj.offerDescription && offerObj.offerDescription.tncText) ? offerObj.offerDescription.tncText : null;
# #       const logo = offerObj.logo || (summary && summary.iconsInfo && Array.isArray(summary.iconsInfo.icons) ? summary.iconsInfo.icons[0] : null);
# #       const providers = Array.isArray(offerObj.provider) ? offerObj.provider : [];

# #       const minTxnAmount = parseRupeeAmount(description);
# #       const maxDiscount = parseMaxDiscount(description) || parseRupeeAmount(title) || null;

# #       const normalized = {
# #         externalId,
# #         dedupeHash: computeHash({ externalId, title, description, providers }),
# #         title,
# #         summaryTitle: summary ? summary.title : null,
# #         logo,
# #         providers,
# #         description,
# #         tncText,
# #         minTxnAmount,
# #         maxDiscount,
# #         rawPayload: offerObj
# #       };
# #       out.push(normalized);
# #     }
# #   }
# #   return out;
# # }

# # // ---------------- POST /offer endpoint ----------------
# # app.post('/offer', async (req, res) => {
# #   try {
# #     const payload = req.body.flipkartOfferApiResponse || req.body;
# #     if (!payload || Object.keys(payload).length === 0) {
# #       return res.status(400).json({ error: 'flipkartOfferApiResponse missing or empty' });
# #     }

# #     const normalizedOffers = extractOffersFromPaymentsResponse(payload);
# #     const noOfOffersIdentified = normalizedOffers.length;
# #     let noOfNewOffersCreated = 0;

# #     for (const n of normalizedOffers) {
# #       let exists = null;
# #       if (n.externalId) {
# #         exists = await Offer.findOne({ externalId: n.externalId }).lean();
# #       }
# #       if (!exists) {
# #         exists = await Offer.findOne({ dedupeHash: n.dedupeHash }).lean();
# #       }
# #       if (!exists) {
# #         try {
# #           await Offer.create(n);
# #           noOfNewOffersCreated++;
# #         } catch (e) {
# #           if (e.code === 11000) {
# #             // unique index violation - treat as duplicate
# #           } else {
# #             console.error('DB insert error', e);
# #           }
# #         }
# #       }
# #     }

# #     return res.json({ noOfOffersIdentified, noOfNewOffersCreated });

# #   } catch (err) {
# #     console.error(err);
# #     return res.status(500).json({ error: 'internal_error' });
# #   }
# # });

# # // ---------------- start server ----------------
# # const PORT = process.env.PORT || 3000;
# # const MONGO = process.env.MONGO_URI || 'mongodb://localhost:27017/piepay_offers';

# # mongoose.connect(MONGO, { useNewUrlParser: true, useUnifiedTopology: true })
# #   .then(() => app.listen(PORT, () => console.log(`Server running on ${PORT}`)))
# #   .catch(err => {
# #     console.error('mongo connect failed', err);
# #     process.exit(1);
# #   });
